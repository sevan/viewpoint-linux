.\" Copyright (c) 2020 by Alejandro Colomar <colomar.6.4.3@gmail.com>
.\" and Copyright (c) 2020 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"
.TH SYSTEM_DATA_TYPES 7 2020-12-21 "Linux" "Linux Programmer's Manual"
.SH NAME
system_data_types \- overview of system data types
.SH DESCRIPTION
.\" Layout:
.\"	A list of type names (the struct/union keyword will be omitted).
.\"	Each entry will have the following parts:
.\"		* Include (see NOTES)
.\"
.\"		* Definition (no "Definition" header)
.\"			Only struct/union types will have definition;
.\"			typedefs will remain opaque.
.\"
.\"		* Description (no "Description" header)
.\"			A few lines describing the type.
.\"
.\"		* Versions (optional)
.\"
.\"		* Conforming to (see NOTES)
.\"			Format: CXY and later; POSIX.1-XXXX and later.
.\"
.\"		* Notes (optional)
.\"
.\"		* Bugs (if any)
.\"
.\"		* See also
.\"------------------------------------- aiocb ------------------------/
.TP
.I aiocb
.RS
.IR Include :
.IR <aio.h> .
.PP
.EX
struct aiocb {
    int             aio_fildes;    /* File descriptor */
    off_t           aio_offset;    /* File offset */
    volatile void  *aio_buf;       /* Location of buffer */
    size_t          aio_nbytes;    /* Length of transfer */
    int             aio_reqprio;   /* Request priority offset */
    struct sigevent aio_sigevent;  /* Signal number and value */
    int             aio_lio_opcode;/* Operation to be performed */
};
.EE
.PP
For further information about this structure, see
.BR aio (7).
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR aio_cancel (3),
.BR aio_error (3),
.BR aio_fsync (3),
.BR aio_read (3),
.BR aio_return (3),
.BR aio_suspend (3),
.BR aio_write (3),
.BR lio_listio (3)
.RE
.\"------------------------------------- clock_t ----------------------/
.TP
.I clock_t
.RS
.IR Include :
.I <time.h>
or
.IR <sys/types.h> .
Alternatively,
.IR <sys/time.h> .
.PP
Used for system time in clock ticks or
.B CLOCKS_PER_SEC
(defined in
.IR <time.h> ).
According to POSIX,
it shall be an integer type or a real-floating type.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR times (2),
.BR clock (3)
.RE
.\"------------------------------------- clockid_t --------------------/
.TP
.I clockid_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <time.h> .
.PP
Used for clock ID type in the clock and timer functions.
According to POSIX,
it shall be defined as an arithmetic type.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR clock_adjtime (2),
.BR clock_getres (2),
.BR clock_nanosleep (2),
.BR timer_create (2),
.BR clock_getcpuclockid (3)
.RE
.\"------------------------------------- dev_t ------------------------/
.TP
.I dev_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <sys/stat.h> .
.PP
Used for device IDs.
According to POSIX,
it shall be an integer type.
For further details of this type, see
.BR makedev (3).
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR mknod (2),
.BR stat (2)
.RE
.\"------------------------------------- div_t ------------------------/
.TP
.I div_t
.RS
.IR Include :
.IR <stdlib.h> .
.PP
.EX
typedef struct {
    int quot; /* Quotient */
    int rem;  /* Remainder */
} div_t;
.EE
.PP
It is the type of the value returned by the
.BR div (3)
function.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR div (3)
.RE
.\"------------------------------------- double_t ---------------------/
.TP
.I double_t
.RS
.IR Include :
.IR <math.h> .
.PP
The implementation's most efficient floating type at least as wide as
.IR double .
Its type depends on the value of the macro
.B FLT_EVAL_METHOD
(defined in
.IR <float.h> ):
.TP
0
.I double_t
is
.IR double .
.TP
1
.I double_t
is
.IR double .
.TP
2
.I double_t
is
.IR "long double" .
.PP
For other values of
.BR FLT_EVAL_METHOD ,
the type of
.I double_t
is implementation-defined.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.I float_t
type in this page.
.RE
.\"------------------------------------- fd_set -----------------------/
.TP
.I fd_set
.RS
.IR Include :
.IR <sys/select.h> .
Alternatively,
.IR <sys/time.h> .
.PP
A structure type that can represent a set of file descriptors.
According to POSIX,
the maximum number of file descriptors in an
.I fd_set
structure is the value of the macro
.BR FD_SETSIZE .
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR select (2)
.RE
.\"------------------------------------- fenv_t -----------------------/
.TP
.I fenv_t
.RS
.IR Include :
.IR <fenv.h> .
.PP
This type represents the entire floating-point environment,
including control modes and status flags; for further details, see
.BR fenv (3).
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR fenv (3)
.RE
.\"------------------------------------- fexcept_t --------------------/
.TP
.I fexcept_t
.RS
.IR Include :
.IR <fenv.h> .
.PP
This type represents the floating-point status flags collectively;
for further details see
.BR fenv (3).
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR fenv (3)
.RE
.\"------------------------------------- FILE -------------------------/
.TP
.I FILE
.RS
.IR Include :
.IR <stdio.h> .
Alternatively,
.IR <wchar.h> .
.PP
An object type used for streams.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR fclose (3),
.BR flockfile (3),
.BR fopen (3),
.BR fprintf (3),
.BR fread (3),
.BR fscanf (3),
.BR stdin (3),
.BR stdio (3)
.RE
.\"------------------------------------- float_t ----------------------/
.TP
.I float_t
.RS
.IR Include :
.IR <math.h> .
.PP
The implementation's most efficient floating type at least as wide as
.IR float .
Its type depends on the value of the macro
.B FLT_EVAL_METHOD
(defined in
.IR <float.h> ):
.TP
0
.I float_t
is
.IR float .
.TP
1
.I float_t
is
.IR double .
.TP
2
.I float_t
is
.IR "long double" .
.PP
For other values of
.BR FLT_EVAL_METHOD ,
the type of
.I float_t
is implementation-defined.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.I double_t
type in this page.
.RE
.\"------------------------------------- gid_t ------------------------/
.TP
.I gid_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <grp.h> ,
.IR <pwd.h> ,
.IR <signal.h> ,
.IR <stropts.h> ,
.IR <sys/ipc.h> ,
.IR <sys/stat.h> ,
or
.IR <unistd.h> .
.PP
A type used to hold group IDs.
According to POSIX,
this shall be an integer type.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR chown (2),
.BR getgid (2),
.BR getegid (2),
.BR getgroups (2),
.BR getresgid (2),
.BR getgrnam (2),
.BR credentials (7)
.RE
.\"------------------------------------- id_t -------------------------/
.TP
.I id_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <sys/resource.h> .
.PP
A type used to hold a general identifier.
According to POSIX,
this shall be an integer type that can be used to contain a
.IR pid_t ,
.IR uid_t ,
or
.IR gid_t .
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR getpriority (2),
.BR waitid (2)
.RE
.\"------------------------------------- imaxdiv_t --------------------/
.TP
.I imaxdiv_t
.RS
.IR Include :
.IR <inttypes.h> .
.PP
.EX
typedef struct {
    intmax_t    quot; /* Quotient */
    intmax_t    rem;  /* Remainder */
} imaxdiv_t;
.EE
.PP
It is the type of the value returned by the
.BR imaxdiv (3)
function.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR imaxdiv (3)
.RE
.\"------------------------------------- intmax_t ---------------------/
.TP
.I intmax_t
.RS
.IR Include :
.IR <stdint.h> .
Alternatively,
.IR <inttypes.h> .
.PP
A signed integer type
capable of representing any value of any signed integer type
supported by the implementation.
According to the C language standard, it shall be
capable of storing values in the range
.RB [ INTMAX_MIN ,
.BR INTMAX_MAX ].
.PP
The macro
.BR INTMAX_C ()
.\" TODO: Document INT*_C(3)
expands its argument to an integer constant of type
.IR intmax_t .
.PP
The length modifier for
.I intmax_t
for the
.BR printf (3)
and the
.BR scanf (3)
families of functions is
.BR j ;
resulting commonly in
.B %jd
or
.B %ji
for printing
.I intmax_t
values.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR Bugs :
.I intmax_t
is not large enough to represent values of type
.I __int128
in implementations where
.I __int128
is defined and
.I long long
is less than 128 bits wide.
.PP
.IR "See also" :
the
.I uintmax_t
type in this page.
.RE
.\"------------------------------------- intN_t -----------------------/
.TP
.IR int N _t
.RS
.IR Include :
.IR <stdint.h> .
Alternatively,
.IR <inttypes.h> .
.PP
.IR int8_t ,
.IR int16_t ,
.IR int32_t ,
.I int64_t
.PP
A signed integer type
of a fixed width of exactly N bits,
N being the value specified in its type name.
According to the C language standard, they shall be
capable of storing values in the range
.RB [ INT N _MIN ,
.BR INT N _MAX ],
substituting N by the appropriate number.
.PP
According to POSIX,
.IR int8_t ,
.IR int16_t ,
and
.I int32_t
are required;
.I int64_t
is only required in implementations that provide integer types
with width 64;
and all other types of this form are optional.
.PP
The length modifiers for the
.IR int N _t
types for the
.BR printf (3)
family of functions
are expanded by macros of the forms
.BR PRId N
and
.BR PRIi N
(defined in
.IR <inttypes.h> );
resulting for example in
.B %"PRId64"
or
.B %"PRIi64"
for printing
.I int64_t
values.
The length modifiers for the
.IR int N _t
types for the
.BR scanf (3)
family of functions
are expanded by macros of the forms
.BR SCNd N
and
.BR SCNi N,
(defined in
.IR <inttypes.h> );
resulting for example in
.B %"SCNd8"
or
.B %"SCNi8"
for scanning
.I int8_t
values.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.IR intmax_t ,
.IR uint N _t ,
and
.I uintmax_t
types in this page.
.RE
.\"------------------------------------- intptr_t ---------------------/
.TP
.I intptr_t
.RS
.IR Include :
.IR <stdint.h> .
Alternatively,
.IR <inttypes.h> .
.PP
A signed integer type
such that any valid
.RI ( "void *" )
value can be converted to this type and back.
According to the C language standard, it shall be
capable of storing values in the range
.RB [ INTPTR_MIN ,
.BR INTPTR_MAX ].
.PP
The length modifier for
.I intptr_t
for the
.BR printf (3)
family of functions
is expanded by the macros
.B PRIdPTR
and
.B PRIiPTR
(defined in
.IR <inttypes.h> );
resulting commonly in
.B %"PRIdPTR"
or
.B %"PRIiPTR"
for printing
.I intptr_t
values.
The length modifier for
.I intptr_t
for the
.BR scanf (3)
family of functions
is expanded by the macros
.B SCNdPTR
and
.B SCNiPTR,
(defined in
.IR <inttypes.h> );
resulting commonly in
.B %"SCNdPTR"
or
.B %"SCNiPTR"
for scanning
.I intptr_t
values.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.I uintptr_t
and
.I void *
types in this page.
.RE
.\"------------------------------------- lconv ------------------------/
.TP
.I lconv
.RS
.IR Include :
.IR <locale.h> .
.PP
.EX
struct lconv {                  /* Values in the "C" locale: */
    char   *decimal_point;      /* "." */
    char   *thousands_sep;      /* "" */
    char   *grouping;           /* "" */
    char   *mon_decimal_point;  /* "" */
    char   *mon_thousands_sep;  /* "" */
    char   *mon_grouping;       /* "" */
    char   *positive_sign;      /* "" */
    char   *negative_sign;      /* "" */
    char   *currency_symbol;    /* "" */
    char    frac_digits;        /* CHAR_MAX */
    char    p_cs_precedes;      /* CHAR_MAX */
    char    n_cs_precedes;      /* CHAR_MAX */
    char    p_sep_by_space;     /* CHAR_MAX */
    char    n_sep_by_space;     /* CHAR_MAX */
    char    p_sign_posn;        /* CHAR_MAX */
    char    n_sign_posn;        /* CHAR_MAX */
    char   *int_curr_symbol;    /* "" */
    char    int_frac_digits;    /* CHAR_MAX */
    char    int_p_cs_precedes;  /* CHAR_MAX */
    char    int_n_cs_precedes;  /* CHAR_MAX */
    char    int_p_sep_by_space; /* CHAR_MAX */
    char    int_n_sep_by_space; /* CHAR_MAX */
    char    int_p_sign_posn;    /* CHAR_MAX */
    char    int_n_sign_posn;    /* CHAR_MAX */
};
.EE
.PP
Contains members related to the formatting of numeric values.
In the "C" locale, its members have the values
shown in the comments above.
.PP
.IR "Conforming to" :
C11 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR setlocale (3),
.BR localeconv (3),
.BR charsets (5),
.BR locale (7)
.RE
.\"------------------------------------- ldiv_t -----------------------/
.TP
.I ldiv_t
.RS
.IR Include :
.IR <stdlib.h> .
.PP
.EX
typedef struct {
    long    quot; /* Quotient */
    long    rem;  /* Remainder */
} ldiv_t;
.EE
.PP
It is the type of the value returned by the
.BR ldiv (3)
function.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR ldiv (3)
.RE
.\"------------------------------------- lldiv_t ----------------------/
.TP
.I lldiv_t
.RS
.IR Include :
.IR <stdlib.h> .
.PP
.EX
typedef struct {
    long long   quot; /* Quotient */
    long long   rem;  /* Remainder */
} lldiv_t;
.EE
.PP
It is the type of the value returned by the
.BR lldiv (3)
function.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR lldiv (3)
.RE
.\"------------------------------------- off_t ------------------------/
.TP
.I off_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <aio.h> ,
.IR <fcntl.h> ,
.IR <stdio.h> ,
.IR <sys/mman.h> ,
.IR <sys/stat.h.h> ,
or
.IR <unistd.h> .
.PP
Used for file sizes.
According to POSIX,
this shall be a signed integer type.
.PP
.IR Versions :
.I <aio.h>
and
.I <stdio.h>
define
.I off_t
since POSIX.1-2008.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR Notes :
On some architectures,
the width of this type can be controlled with the feature test macro
.BR _FILE_OFFSET_BITS .
.PP
.IR "See also" :
.\" .BR fallocate (2),
.BR lseek (2),
.BR mmap (2),
.\" .BR mmap2 (2),
.BR posix_fadvise (2),
.BR pread (2),
.\" .BR preadv (2),
.BR truncate (2),
.BR fseeko (3),
.\" .BR getdirentries (3),
.BR lockf (3),
.BR posix_fallocate (3),
.BR feature_test_macros (7)
.\".PP		TODO: loff_t, off64_t
.\"See also the
.\".I loff_t
.\"and
.\".I off64_t
.\"types in this page.
.RE
.\"------------------------------------- pid_t ------------------------/
.TP
.I pid_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <fcntl.h> ,
.IR <sched.h> ,
.IR <signal.h> ,
.IR <spawn.h> ,
.IR <sys/msg.h> ,
.IR <sys/sem.h> ,
.IR <sys/shm.h> ,
.IR <sys/wait.h> ,
.IR <termios.h> ,
.IR <time.h> ,
.IR <unistd.h> ,
or
.IR <utmpx.h> .
.PP
This type is used for storing process IDs, process group IDs, and session IDs.
According to POSIX, it shall be a signed integer type,
and the implementation shall support one or more programming environments
where the width of
.I pid_t
is no greater than the width of the type
.IR long .
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR fork (2),
.BR getpid (2),
.BR getppid (2),
.BR getsid (2),
.BR gettid (2),
.BR getpgid (2),
.BR kill (2),
.BR pidfd_open (2),
.BR sched_setscheduler (2),
.BR waitpid (2),
.BR sigqueue (3),
.BR credentials (7),
.RE
.\"------------------------------------- ptrdiff_t --------------------/
.TP
.I ptrdiff_t
.RS
.IR Include :
.IR <stddef.h> .
.PP
Used for a count of elements, and array indices.
It is the result of subtracting two pointers.
According to the C language standard, it shall be a signed integer type
capable of storing values in the range
.RB [ PTRDIFF_MIN ,
.BR PTRDIFF_MAX ].
.PP
The length modifier for
.I ptrdiff_t
for the
.BR printf (3)
and the
.BR scanf (3)
families of functions is
.BR t ;
resulting commonly in
.B %td
or
.B %ti
for printing
.I ptrdiff_t
values.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.I size_t
and
.I ssize_t
types in this page.
.RE
.\"------------------------------------- regex_t ----------------------/
.TP
.I regex_t
.RS
.IR Include :
.IR <regex.h> .
.PP
.EX
typedef struct {
    size_t  re_nsub; /* Number of parenthesized subexpressions. */
} regex_t;
.EE
.PP
This is a structure type used in regular expression matching.
It holds a compiled regular expression, compiled with
.BR regcomp (3).
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR regex (3)
.RE
.\"------------------------------------- regmatch_t -------------------/
.TP
.I regmatch_t
.RS
.IR Include :
.IR <regex.h> .
.PP
.EX
typedef struct {
    regoff_t    rm_so; /* Byte offset from start of string
                          to start of substring */
    regoff_t    rm_eo; /* Byte offset from start of string of
                          the first character after the end of
                          substring */
} regmatch_t;
.EE
.PP
This is a structure type used in regular expression matching.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR regexec (3)
.RE
.\"------------------------------------- regoff_t ---------------------/
.TP
.I regoff_t
.RS
.IR Include :
.IR <regex.h> .
.PP
According to POSIX, it shall be a signed integer type
capable of storing the largest value that can be stored in either a
.I ptrdiff_t
type or a
.I ssize_t
type.
.PP
.IR Versions :
Prior to POSIX.1-2008, the type was capable of storing
the largest value that can be stored in either an
.I off_t
type or a
.I ssize_t
type.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.I regmatch_t
structure and the
.I ptrdiff_t
and
.I ssize_t
types in this page.
.RE
.\"------------------------------------- sigevent ---------------------/
.TP
.I sigevent
.RS
.IR Include :
.IR <signal.h> .
Alternatively,
.IR <aio.h> ,
.IR <mqueue.h> ,
or
.IR <time.h> .
.PP
.EX
struct sigevent {
    int             sigev_notify; /* Notification type */
    int             sigev_signo;  /* Signal number */
    union sigval    sigev_value;  /* Signal value */
    void          (*sigev_notify_function)(union sigval);
                                  /* Notification function */
    pthread_attr_t *sigev_notify_attributes;
                                  /* Notification attributes */
};
.EE
.PP
For further details about this type, see
.BR sigevent (7).
.PP
.IR Versions :
.I <aio.h>
and
.I <time.h>
define
.I sigevent
since POSIX.1-2008.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR timer_create (2),
.BR getaddrinfo_a (3),
.BR lio_listio (3),
.BR mq_notify (3)
.PP
See also the
.I aiocb
structure in this page.
.RE
.\"------------------------------------- siginfo_t --------------------/
.TP
.I siginfo_t
.RS
.IR Include :
.IR <signal.h> .
Alternatively,
.IR <sys/wait.h> .
.PP
.EX
typedef struct {
    int      si_signo;  /* Signal number */
    int      si_code;   /* Signal code */
    pid_t    si_pid;    /* Sending process ID */
    uid_t    si_uid;    /* Real user ID of sending process */
    void    *si_addr;   /* Address of faulting instruction */
    int      si_status; /* Exit value or signal */
    union sigval si_value;  /* Signal value */
} siginfo_t;
.EE
.PP
Information associated with a signal.
For further details on this structure
(including additional, Linux-specific fields), see
.BR sigaction (2).
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR pidfd_send_signal (2),
.BR rt_sigqueueinfo (2),
.BR sigaction (2),
.BR sigwaitinfo (2),
.BR psiginfo (3)
.RE
.\"------------------------------------- sigset_t ---------------------/
.TP
.I sigset_t
.RS
.IR Include :
.IR <signal.h> .
Alternatively,
.IR <spawn.h> ,
or
.IR <sys/select.h> .
.PP
This is a type that represents a set of signals.
According to POSIX, this shall be an integer or structure type.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR epoll_pwait (2),
.BR ppoll (2),
.BR pselect (2),
.BR sigaction (2),
.BR signalfd (2),
.BR sigpending (2),
.BR sigprocmask (2),
.BR sigsuspend (2),
.BR sigwaitinfo (2),
.BR signal (7)
.RE
.\"------------------------------------- sigval -----------------------/
.TP
.I sigval
.RS
.IR Include :
.IR <signal.h> .
.PP
.EX
union sigval {
    int     sigval_int; /* Integer value */
    void   *sigval_ptr; /* Pointer value */
};
.EE
.PP
Data passed with a signal.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR pthread_sigqueue (3),
.BR sigqueue (3),
.BR sigevent (7)
.PP
See also the
.I sigevent
structure
and the
.I siginfo_t
type
in this page.
.RE
.\"------------------------------------- size_t -----------------------/
.TP
.I size_t
.RS
.IR Include :
.I <stddef.h>
or
.IR <sys/types.h> .
Alternatively,
.IR <aio.h> ,
.IR <glob.h> ,
.IR <grp.h> ,
.IR <iconv.h> ,
.IR <monetary.h> ,
.IR <mqueue.h> ,
.IR <ndbm.h> ,
.IR <pwd.h> ,
.IR <regex.h> ,
.IR <search.h> ,
.IR <signal.h> ,
.IR <stdio.h> ,
.IR <stdlib.h> ,
.IR <string.h> ,
.IR <strings.h> ,
.IR <sys/mman.h> ,
.IR <sys/msg.h> ,
.IR <sys/sem.h> ,
.IR <sys/shm.h> ,
.IR <sys/socket.h> ,
.IR <sys/uio.h> ,
.IR <time.h> ,
.IR <unistd.h> ,
.IR <wchar.h> ,
or
.IR <wordexp.h> .
.PP
Used for a count of bytes.  It is the result of the
.I sizeof
operator.
According to the C language standard,
it shall be an unsigned integer type
capable of storing values in the range [0,
.BR SIZE_MAX ].
According to POSIX,
the implementation shall support one or more programming environments
where the width of
.I size_t
is no greater than the width of the type
.IR long .
.PP
The length modifier for
.I size_t
for the
.BR printf (3)
and the
.BR scanf (3)
families of functions is
.BR z ;
resulting commonly in
.B %zu
or
.B %zx
for printing
.I size_t
values.
.PP
.IR Versions :
.IR <aio.h> ,
.IR <glob.h> ,
.IR <grp.h> ,
.IR <iconv.h> ,
.IR <mqueue.h> ,
.IR <pwd.h> ,
.IR <signal.h> ,
and
.I <sys/socket.h>
define
.I size_t
since POSIX.1-2008.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR read (2),
.BR write (2),
.BR fread (3),
.BR fwrite (3),
.BR memcmp (3),
.BR memcpy (3),
.BR memset (3),
.BR offsetof (3)
.PP
See also the
.I ptrdiff_t
and
.I ssize_t
types in this page.
.RE
.\"------------------------------------- ssize_t ----------------------/
.TP
.I ssize_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <aio.h> ,
.IR <monetary.h> ,
.IR <mqueue.h> ,
.IR <stdio.h> ,
.IR <sys/msg.h> ,
.IR <sys/socket.h> ,
.IR <sys/uio.h> ,
or
.IR <unistd.h> .
.PP
Used for a count of bytes or an error indication.
According to POSIX, it shall be a signed integer type
capable of storing values at least in the range [-1,
.BR SSIZE_MAX ],
and the implementation shall support one or more programming environments
where the width of
.I ssize_t
is no greater than the width of the type
.IR long .
.PP
Glibc and most other implementations provide a length modifier for
.I ssize_t
for the
.BR printf (3)
and the
.BR scanf (3)
families of functions, which is
.BR z ;
resulting commonly in
.B %zd
or
.B %zi
for printing
.I ssize_t
values.
Although
.B z
works for
.I ssize_t
on most implementations,
portable POSIX programs should avoid using it\(emfor example,
by converting the value to
.I intmax_t
and using its length modifier
.RB ( j ).
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR read (2),
.BR readlink (2),
.BR readv (2),
.BR recv (2),
.BR send (2),
.BR write (2)
.PP
See also the
.I ptrdiff_t
and
.I size_t
types in this page.
.RE
.\"------------------------------------- suseconds_t ------------------/
.TP
.I suseconds_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <sys/select.h> ,
or
.IR <sys/time.h> .
.PP
Used for time in microseconds.
According to POSIX, it shall be a signed integer type
capable of storing values at least in the range [-1, 1000000],
and the implementation shall support one or more programming environments
where the width of
.I suseconds_t
is no greater than the width of the type
.IR long .
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.I timeval
structure in this page.
.RE
.\"------------------------------------- time_t -----------------------/
.TP
.I time_t
.RS
.IR Include :
.I <time.h>
or
.IR <sys/types.h> .
Alternatively,
.IR <sched.h> ,
.IR <sys/msg.h> ,
.IR <sys/select.h> ,
.IR <sys/sem.h> ,
.IR <sys/shm.h> ,
.IR <sys/stat.h> ,
.IR <sys/time.h> ,
or
.IR <utime.h> .
.PP
Used for time in seconds.
According to POSIX, it shall be an integer type.
.\" In POSIX.1-2001, the type was specified as being either an integer
.\" type or a real-floating type. However, existing implementations
.\" used an integer type, and POSIX.1-2008 tightened the specification
.\" to reflect this.
.PP
.IR Versions :
.I <sched.h>
defines
.I time_t
since POSIX.1-2008.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR stime (2),
.BR time (2),
.BR ctime (3),
.BR difftime (3)
.RE
.\"------------------------------------- timer_t ----------------------/
.TP
.I timer_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <time.h> .
.PP
Used for timer ID returned by
.BR timer_create (2).
According to POSIX,
there are no defined comparison or assignment operators for this type.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR timer_create (2),
.BR timer_delete (2),
.BR timer_getoverrun (2),
.BR timer_settime (2)
.RE
.\"------------------------------------- timespec ---------------------/
.TP
.I timespec
.RS
.IR Include :
.IR <time.h> .
Alternatively,
.IR <aio.h> ,
.IR <mqueue.h> ,
.IR <sched.h> ,
.IR <signal.h> ,
.IR <sys/select.h> ,
or
.IR <sys/stat.h> .
.PP
.EX
struct timespec {
    time_t  tv_sec;  /* Seconds */
    long    tv_nsec; /* Nanoseconds */
};
.EE
.PP
Describes times in seconds and nanoseconds.
.PP
.IR "Conforming to" :
C11 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR clock_gettime (2),
.BR clock_nanosleep (2),
.BR nanosleep (2),
.BR timerfd_gettime (2),
.BR timer_gettime (2)
.RE
.\"------------------------------------- timeval ----------------------/
.TP
.I timeval
.RS
.IR Include :
.IR <sys/time.h> .
Alternatively,
.IR <sys/resource.h> ,
.IR <sys/select.h> ,
or
.IR <utmpx.h> .
.PP
.EX
struct timeval {
    time_t      tv_sec;  /* Seconds */
    suseconds_t tv_usec; /* Microseconds */
};
.EE
.PP
Describes times in seconds and microseconds.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR gettimeofday (2),
.BR select (2),
.BR utimes (2),
.BR adjtime (3),
.BR futimes (3),
.BR timeradd (3)
.RE
.\"------------------------------------- uid_t ----------------------/
.TP
.I uid_t
.RS
.IR Include :
.IR <sys/types.h> .
Alternatively,
.IR <pwd.h> ,
.IR <signal.h> ,
.IR <stropts.h> ,
.IR <sys/ipc.h> ,
.IR <sys/stat.h> ,
or
.IR <unistd.h> .
.PP
A type used to hold user IDs.
According to POSIX,
this shall be an integer type.
.PP
.IR "Conforming to" :
POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR chown (2),
.BR getuid (2),
.BR geteuid (2),
.BR getresuid (2),
.BR getpwnam (2),
.BR credentials (7)
.RE
.\"------------------------------------- uintmax_t --------------------/
.TP
.I uintmax_t
.RS
.IR Include :
.IR <stdint.h> .
Alternatively,
.IR <inttypes.h> .
.PP
An unsigned integer type
capable of representing any value of any unsigned integer type
supported by the implementation.
According to the C language standard, it shall be
capable of storing values in the range [0,
.BR UINTMAX_MAX ].
.PP
The macro
.BR UINTMAX_C ()
.\" TODO: Document UINT*_C(3)
expands its argument to an integer constant of type
.IR uintmax_t .
.PP
The length modifier for
.I uintmax_t
for the
.BR printf (3)
and the
.BR scanf (3)
families of functions is
.BR j ;
resulting commonly in
.B %ju
or
.B %jx
for printing
.I uintmax_t
values.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR Bugs :
.I uintmax_t
is not large enough to represent values of type
.I unsigned __int128
in implementations where
.I unsigned __int128
is defined and
.I unsigned long long
is less than 128 bits wide.
.PP
.IR "See also" :
the
.I intmax_t
type in this page.
.RE
.\"------------------------------------- uintN_t ----------------------/
.TP
.IR uint N _t
.RS
.IR Include :
.IR <stdint.h> .
Alternatively,
.IR <inttypes.h> .
.PP
.IR uint8_t ,
.IR uint16_t ,
.IR uint32_t ,
.I uint64_t
.PP
An unsigned integer type
of a fixed width of exactly N bits,
N being the value specified in its type name.
According to the C language standard, they shall be
capable of storing values in the range [0,
.BR UINT N _MAX ],
substituting N by the appropriate number.
.PP
According to POSIX,
.IR uint8_t ,
.IR uint16_t ,
and
.I uint32_t
are required;
.I uint64_t
is only required in implementations that provide integer types
with width 64;
and all other types of this form are optional.
.PP
The length modifiers for the
.IR uint N _t
types for the
.BR printf (3)
family of functions
are expanded by macros of the forms
.BR PRIu N,
.BR PRIo N,
.BR PRIx N,
and
.BR PRIX N
(defined in
.IR <inttypes.h> );
resulting for example in
.B %"PRIu32"
or
.B %"PRIx32"
for printing
.I uint32_t
values.
The length modifiers for the
.IR uint N _t
types for the
.BR scanf (3)
family of functions
are expanded by macros of the forms
.BR SCNu N,
.BR SCNo N,
.BR SCNx N,
and
.BR SCNX N
(defined in
.IR <inttypes.h> );
resulting for example in
.B %"SCNu16"
or
.B %"SCNx16"
for scanning
.I uint16_t
values.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.IR intmax_t ,
.IR int N _t ,
and
.IR uintmax_t
types in this page.
.RE
.\"------------------------------------- uintptr_t --------------------/
.TP
.I uintptr_t
.RS
.IR Include :
.IR <stdint.h> .
Alternatively,
.IR <inttypes.h> .
.PP
An unsigned integer type
such that any valid
.RI ( "void *" )
value can be converted to this type and back.
According to the C language standard, it shall be
capable of storing values in the range [0,
.BR UINTPTR_MAX ].
.PP
The length modifier for
.I uintptr_t
for the
.BR printf (3)
family of functions
is expanded by the macros
.BR PRIuPTR ,
.BR PRIoPTR ,
.BR PRIxPTR ,
and
.B PRIXPTR
(defined in
.IR <inttypes.h> );
resulting commonly in
.B %"PRIuPTR"
or
.B %"PRIxPTR"
for printing
.I uintptr_t
values.
The length modifier for
.I uintptr_t
for the
.BR scanf (3)
family of functions
is expanded by the macros
.BR SCNuPTR,
.BR SCNoPTR,
.BR SCNxPTR ,
and
.B SCNXPTR
(defined in
.IR <inttypes.h> );
resulting commonly in
.B %"SCNuPTR"
or
.B %"SCNxPTR"
for scanning
.I uintptr_t
values.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
the
.I intptr_t
and
.I void *
types in this page.
.RE
.\"------------------------------------- va_list ----------------------/
.TP
.I va_list
.RS
.IR Include :
.IR <stdarg> .
Alternatively,
.IR <stdio.h> ,
or
.IR <wchar.h> .
.PP
Used by functions with a varying number of arguments of varying types.
The function must declare an object of type
.I va_list
which is used by the macros
.BR va_start (3),
.BR va_arg (3),
.BR va_copy (3),
and
.BR va_end (3)
to traverse the list of arguments.
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR va_start (3),
.BR va_arg (3),
.BR va_copy (3),
.BR va_end (3)
.RE
.\"------------------------------------- void * -----------------------/
.TP
.I void *
.RS
According to the C language standard,
a pointer to any object type may be converted to a pointer to
.I void
and back.
POSIX further requires that any pointer,
including pointers to functions,
may be converted to a pointer to
.I void
and back.
.PP
Conversions from and to any other pointer type are done implicitly,
not requiring casts at all.
Note that this feature prevents any kind of type checking:
the programmer should be careful not to convert a
.I void *
value to a type incompatible to that of the underlying data,
because that would result in undefined behavior.
.PP
This type is useful in function parameters and return value
to allow passing values of any type.
The function will typically use some mechanism to know
the real type of the data being passed via a pointer to
.IR void .
.PP
A value of this type can't be dereferenced,
as it would give a value of type
.IR void ,
which is not possible.
Likewise, pointer arithmetic is not possible with this type.
However, in GNU C, pointer arithmetic is allowed
as an extension to the standard;
this is done by treating the size of a
.I void
or of a function as 1.
A consequence of this is that
.I sizeof
is also allowed on
.I void
and on function types, and returns 1.
.PP
The conversion specifier for
.I void *
for the
.BR printf (3)
and the
.BR scanf (3)
families of functions is
.BR p .
.PP
.IR Versions :
The POSIX requirement about compatibility between
.I void *
and function pointers was added in
POSIX.1-2008 Technical Corrigendum 1 (2013).
.PP
.IR "Conforming to" :
C99 and later; POSIX.1-2001 and later.
.PP
.IR "See also" :
.BR malloc (3),
.BR memcmp (3),
.BR memcpy (3),
.BR memset (3)
.PP
See also the
.I intptr_t
and
.I uintptr_t
types in this page.
.RE
.\"--------------------------------------------------------------------/
.SH NOTES
The structures described in this manual page shall contain,
at least, the members shown in their definition, in no particular order.
.PP
Most of the integer types described in this page don't have
a corresponding length modifier for the
.BR printf (3)
and the
.BR scanf (3)
families of functions.
To print a value of an integer type that doesn't have a length modifier,
it should be converted to
.I intmax_t
or
.I uintmax_t
by an explicit cast.
To scan into a variable of an integer type
that doesn't have a length modifier,
an intermediate temporary variable of type
.I intmax_t
or
.I uintmax_t
should be used.
When copying from the temporary variable to the destination variable,
the value could overflow.
If the type has upper and lower limits,
the user should check that the value is within those limits,
before actually copying the value.
The example below shows how these conversions should be done.
.SS Conventions used in this page
In "Conforming to" we only concern ourselves with
C99 and later and POSIX.1-2001 and later.
Some types may be specified in earlier versions of one of these standards,
but in the interests of simplicity we omit details from earlier standards.
.PP
In "Include", we first note the "primary" header(s) that
define the type according to either the C or POSIX.1 standards.
Under "Alternatively", we note additional headers that
the standards specify shall define the type.
.SH EXAMPLES
The program shown below scans from a string and prints a value stored in
a variable of an integer type that doesn't have a length modifier.
The appropriate conversions from and to
.IR intmax_t ,
and the appropriate range checks,
are used as explained in the notes section above.
.PP
.EX
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

int
main (void)
{
    static const char *const str = "500000 us in half a second";
    suseconds_t us;
    intmax_t    tmp;

    /* Scan the number from the string into the temporary variable */

    sscanf(str, "%jd", &tmp);

    /* Check that the value is within the valid range of suseconds_t */

    if (tmp < \-1 || tmp > 1000000) {
        fprintf(stderr, "Scanned value outside valid range!\en");
        exit(EXIT_FAILURE);
    }

    /* Copy the value to the suseconds_t variable \(aqus\(aq */

    us = tmp;

    /* Even though suseconds_t can hold the value \-1, this isn\(aqt
       a sensible number of microseconds */

    if (us < 0) {
        fprintf(stderr, "Scanned value shouldn\(aqt be negative!\en");
        exit(EXIT_FAILURE);
    }

    /* Print the value */

    printf("There are %jd microseconds in half a second.\en",
            (intmax_t) us);

    exit(EXIT_SUCCESS);
}
.EE
.SH SEE ALSO
.BR feature_test_macros (7),
.BR standards (7)
.SH COLOPHON
This page is part of release 5.10 of the Linux
.I man-pages
project.
A description of the project,
information about reporting bugs,
and the latest version of this page,
can be found at
\%https://www.kernel.org/doc/man\-pages/.
